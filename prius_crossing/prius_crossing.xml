<?xml version="1.0" ?>
<VisualStates>
  <config>
    <buildDependencies>
      <dependency>rospy</dependency>
      <dependency>sensor_msgs</dependency>
      <dependency>geometry_msgs</dependency>
      <dependency>prius_msgs</dependency>
    </buildDependencies>
    <runDependencies>
      <dependency>rospy</dependency>
      <dependency>sensor_msgs</dependency>
      <dependency>geometry_msgs</dependency>
      <dependency>prius_msgs</dependency>
    </runDependencies>
    <topics>
      <topic id="0">
        <methodname>prius</methodname>
        <name>/prius</name>
        <type>prius_msgs/Control</type>
        <opType>Publish</opType>
      </topic>
      <topic id="1">
        <variablename>prius_front_left_laser_scan</variablename>
        <name>/prius/front_left_laser/scan</name>
        <type>sensor_msgs/LaserScan</type>
        <opType>Subscribe</opType>
      </topic>
      <topic id="2">
        <variablename>prius_front_camera_image_raw</variablename>
        <name>/prius/front_camera/image_raw</name>
        <type>sensor_msgs/Image</type>
        <opType>Subscribe</opType>
      </topic>
      <topic id="3">
        <variablename>joint_states</variablename>
        <name>/joint_states</name>
        <type>sensor_msgs/JointState</type>
        <opType>Subscribe</opType>
      </topic>
      <topic id="4">
        <variablename>prius_front_right_laser_scan</variablename>
        <name>/prius/front_right_laser/scan</name>
        <type>sensor_msgs/LaserScan</type>
        <opType>Subscribe</opType>
      </topic>
    </topics>
  </config>
  <global_namespace>
    <functions>def calculate_throttle(self, desired_velocity):
	&quot;&quot;&quot;
	Proportional Throttle Controller
	&quot;&quot;&quot;
	feedback_velocity = np.average(np.array(self.joint_states.velocity[:4])) # 4 Wheels
	error = desired_velocity - feedback_velocity
	p = 0.01 * error
	if p &gt; 1: return 1
	elif p &lt; -1: return -1
	else: return p</functions>
    <variables></variables>
  </global_namespace>
  <libraries>
    <library>numpy as np</library>
    <library>cv2</library>
  </libraries>
  <state id="0" initial="True">
    <posx>0.0</posx>
    <posy>0.0</posy>
    <name>root</name>
    <code></code>
    <timestep>100</timestep>
    <namespace>
      <functions>def getRangesForAngle(self, min_angle, max_angle, laser):
	&quot;&quot;&quot;
	Applies Angle Mask to Laser
	&quot;&quot;&quot;
	laser_ranges = enumerate(laser.ranges)
	thresh = laser.angle_increment * 180 / 3.14
	ranges = []
	for k, g in enumerate(laser.ranges):
		if k*thresh &gt; min_angle and k*thresh &lt; max_angle:
			ranges.append(g)
	return ranges

def region_of_interest(self, img, vertices):
	&quot;&quot;&quot;
	Applies Image Mask to Image
	&quot;&quot;&quot;
	mask = np.zeros_like(img)
	if len(img.shape) &gt; 2:
		channel_count = img.shape[2]
		ignore_mask_color = (255,) * channel_count
	else:
		ignore_mask_color = 255
	
	cv2.fillPoly(mask, vertices, ignore_mask_color)
	masked_image = cv2.bitwise_and(img,mask)
	return masked_image

def calculate_steer_lane(self):
	&quot;&quot;&quot;
	Proportional Steer based on Lane Detected using Front Camera
	&quot;&quot;&quot;
	error = self.get_steer_error()
	e = 157 - error
	Kp = -0.05
	p = Kp * e
	if p &gt; 1: return 1
	elif p &lt; -1: return -1
	else: return p

def distance(self, x, y):
	import math
	dist = math.sqrt(x ** 2 + y ** 2)
	return dist
	
def get_steer_error(self):
	'''
	Road Lane Detection
	'''
	front_image = self.globalNamespace.prius_front_camera_image_raw
	import cv2
	from cv_bridge import CvBridge
	self.bridge = CvBridge()
	front_image = self.bridge.imgmsg_to_cv2(front_image, &quot;bgr8&quot;)
	vertices = np.array([[(320, 487), (295, 519), (246,513) ,(265, 489)]], dtype=np.int32)
	front_image = self.region_of_interest(front_image, vertices)
	image_hsv = cv2.cvtColor(front_image, cv2.COLOR_BGR2HSV)
	image_mask = cv2.inRange(image_hsv, np.array([0,0,135]), np.array([10,10,215]))
	kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (2, 2))
	closing = cv2.morphologyEx(image_mask, cv2.MORPH_CLOSE, kernel)
	opening = cv2.morphologyEx(closing, cv2.MORPH_OPEN, kernel)
	dilation = cv2.dilate(opening, kernel, iterations=2)
	dilation[dilation &lt; 240] = 0
	_, contours, _ = cv2.findContours(dilation, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)
	contours = sorted(contours, key=cv2.contourArea, reverse=True)[:1]
	center_x = image_mask.shape[0] / 2
	center_y = image_mask.shape[1] / 2
	M = cv2.moments(contours[0])
	cX = int(M[&quot;m10&quot;] / M[&quot;m00&quot;])
	cY = int(M[&quot;m01&quot;] / M[&quot;m00&quot;])
	cv2.drawContours(front_image, contours[0], 7, (255, 20, 255), 1)
	cv2.line(front_image, (center_x, center_y), (cX, cY), (255,10,255), 1)
	errorX = cX - center_x
	errorY = cY - center_y
	error = self.distance(errorX, errorY)
	cv2.imshow(&quot;lanelines&quot;, front_image)
	return error

def is_human(self):
	&quot;&quot;&quot;
	Obstacle Detection using Laser Data
	&quot;&quot;&quot;
	left_laser = self.globalNamespace.prius_front_left_laser_scan
	left_front_ranges = np.array(self.getRangesForAngle(60, 120, left_laser))
	mini = min(left_front_ranges)
	
	if (mini &lt; 2).any():
		self.is_object = True
		return
	self.is_object = False

def stop_sign(self):
	&quot;&quot;&quot;
	Obstacle Detection using Laser Data
	&quot;&quot;&quot;
	right_laser = self.globalNamespace.prius_front_right_laser_scan
	right_front_ranges = np.array(self.getRangesForAngle(180, 240, right_laser))
	mini = min(right_front_ranges)
	if(mini &lt; 4).any():
		self.is_stop_sign = True
		return
	self.is_stop_sign = False
	</functions>
      <variables>self.is_object = False
self.is_stop_sign = False</variables>
    </namespace>
    <state id="1" initial="True">
      <posx>851.0</posx>
      <posy>950.0</posy>
      <name>stay_on_road</name>
      <code>throttle = self.globalNamespace.calculate_throttle(10)
steer = self.namespace.calculate_steer_lane()
command = Control()
command.throttle = throttle
command.brake = 0
command.steer = steer
self.globalNamespace.prius(command)</code>
      <timestep>100</timestep>
      <namespace>
        <functions></functions>
        <variables></variables>
      </namespace>
      <transition id="1">
        <type>1</type>
        <condition>self.namespace.is_human()
return self.namespace.is_object
</condition>
        <posx>908.0</posx>
        <posy>901.0</posy>
        <name>is_human</name>
        <originid>1</originid>
        <destinationid>2</destinationid>
        <code></code>
      </transition>
      <transition id="9">
        <type>1</type>
        <condition>self.namespace.stop_sign()
return self.namespace.is_stop_sign
</condition>
        <posx>907.0</posx>
        <posy>1015.5</posy>
        <name>is_stop_sign</name>
        <originid>1</originid>
        <destinationid>7</destinationid>
        <code></code>
      </transition>
    </state>
    <state id="2" initial="False">
      <posx>965.0</posx>
      <posy>852.0</posy>
      <name>stop_if_human</name>
      <code>command = Control()
command.throttle = 0
command.brake = 0.6
command.steer = 0
self.globalNamespace.prius(command)</code>
      <timestep>100</timestep>
      <namespace>
        <functions></functions>
        <variables></variables>
      </namespace>
      <transition id="2">
        <type>0</type>
        <time>1500</time>
        <posx>1023.5</posx>
        <posy>902.5</posy>
        <name>is_human</name>
        <originid>2</originid>
        <destinationid>3</destinationid>
        <code></code>
      </transition>
    </state>
    <state id="3" initial="False">
      <posx>1082.0</posx>
      <posy>955.0</posy>
      <name>turn_left</name>
      <code></code>
      <timestep>100</timestep>
      <namespace>
        <functions></functions>
        <variables></variables>
      </namespace>
      <transition id="7">
        <type>0</type>
        <time>11000</time>
        <posx>966.5</posx>
        <posy>952.5</posy>
        <name>road_align</name>
        <originid>3</originid>
        <destinationid>1</destinationid>
        <code></code>
      </transition>
      <state id="5" initial="True">
        <posx>954.0</posx>
        <posy>920.0</posy>
        <name>forward</name>
        <code>throttle = self.globalNamespace.calculate_throttle(10)
command = Control()
command.throttle = throttle
command.brake = 0
command.steer = 0
self.globalNamespace.prius(command)</code>
        <timestep>100</timestep>
        <namespace>
          <functions></functions>
          <variables></variables>
        </namespace>
        <transition id="4">
          <type>0</type>
          <time>5000</time>
          <posx>954.0</posx>
          <posy>995.0</posy>
          <name>turn_left</name>
          <originid>5</originid>
          <destinationid>6</destinationid>
          <code></code>
        </transition>
      </state>
      <state id="6" initial="False">
        <posx>954.0</posx>
        <posy>1070.0</posy>
        <name>left</name>
        <code>throttle = self.globalNamespace.calculate_throttle(10)
command = Control()
command.throttle = throttle
command.brake = 0
command.steer = 0.6
self.globalNamespace.prius(command)</code>
        <timestep>100</timestep>
        <namespace>
          <functions></functions>
          <variables></variables>
        </namespace>
      </state>
    </state>
    <state id="7" initial="False">
      <posx>963.0</posx>
      <posy>1081.0</posy>
      <name>stop</name>
      <code>command = Control()
command.throttle = 0
command.brake = 0.6
command.steer = 0
self.globalNamespace.prius(command)</code>
      <timestep>100</timestep>
      <namespace>
        <functions></functions>
        <variables></variables>
      </namespace>
    </state>
  </state>
</VisualStates>
