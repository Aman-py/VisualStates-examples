<?xml version="1.0" ?>
<VisualStates>
  <config type="1">
    <buildDependencies>
      <dependency>rospy</dependency>
      <dependency>sensor_msgs</dependency>
      <dependency>geometry_msgs</dependency>
      <dependency>prius_msgs</dependency>
    </buildDependencies>
    <runDependencies>
      <dependency>rospy</dependency>
      <dependency>sensor_msgs</dependency>
      <dependency>geometry_msgs</dependency>
      <dependency>prius_msgs</dependency>
    </runDependencies>
    <topics>
      <topic id="0">
        <name>/prius</name>
        <type>prius_msgs/Control</type>
        <opType>Publish</opType>
      </topic>
      <topic id="1">
        <name>/prius/front_left_laser/scan</name>
        <type>sensor_msgs/LaserScan</type>
        <opType>Subscribe</opType>
      </topic>
      <topic id="2">
        <name>/prius/front_right_laser/scan</name>
        <type>sensor_msgs/LaserScan</type>
        <opType>Subscribe</opType>
      </topic>
      <topic id="3">
        <name>/joint_states</name>
        <type>sensor_msgs/JointState</type>
        <opType>Subscribe</opType>
      </topic>
      <topic id="4">
        <name>/prius/back_camera/image_raw</name>
        <type>sensor_msgs/Image</type>
        <opType>Subscribe</opType>
      </topic>
      <topic id="5">
        <name>/prius/front_camera/image_raw</name>
        <type>sensor_msgs/Image</type>
        <opType>Subscribe</opType>
      </topic>
      <topic id="6">
        <name>/prius/left_camera/image_raw</name>
        <type>sensor_msgs/Image</type>
        <opType>Subscribe</opType>
      </topic>
      <topic id="7">
        <name>/prius/right_camera/image_raw</name>
        <type>sensor_msgs/Image</type>
        <opType>Subscribe</opType>
      </topic>
      <topic id="8">
        <name>/darknet_ros/bounding_boxes</name>
        <type>darknet_ros_msgs/BoundingBoxes</type>
        <opType>Subscribe</opType>
      </topic>
    </topics>
  </config>
  <global_namespace>
    <functions></functions>
    <variables></variables>
  </global_namespace>
  <libraries>
    <library>numpy as np</library>
    <library>cv2</library>
    <library>math</library>
  </libraries>
  <state id="0" initial="True">
    <posx>0.0</posx>
    <posy>0.0</posy>
    <name>root</name>
    <code></code>
    <timestep>100</timestep>
    <namespace>
      <functions></functions>
      <variables></variables>
    </namespace>
    <state id="1" initial="True">
      <posx>877.0</posx>
      <posy>948.0</posy>
      <name>crossing</name>
      <code></code>
      <timestep>100</timestep>
      <namespace>
        <functions>def getRangesForAngle(self, min_angle, max_angle, laser):
	&quot;&quot;&quot;
	Applies Angle Mask to Laser
	&quot;&quot;&quot;
	laser_ranges = enumerate(laser.ranges)
	thresh = laser.angle_increment * 180 / 3.14
	ranges = []
	for k, g in enumerate(laser.ranges):
		if k*thresh &gt; min_angle and k*thresh &lt; max_angle:
			ranges.append(g)
	return ranges

def region_of_interest(self, img, vertices):
	&quot;&quot;&quot;
	Applies Image Mask to Image
	&quot;&quot;&quot;
	mask = np.zeros_like(img)
	if len(img.shape) &gt; 2:
		channel_count = img.shape[2]
		ignore_mask_color = (255,) * channel_count
	else:
		ignore_mask_color = 255
	
	cv2.fillPoly(mask, vertices, ignore_mask_color)
	masked_image = cv2.bitwise_and(img,mask)
	return masked_image
	
def calculate_steer_laser(self):
	&quot;&quot;&quot;
	Proportional Steer based on Laser Data
	&quot;&quot;&quot;
	left_laser = self.globalNamespace.prius_front_left_laser_scan
	right_laser = self.globalNamespace.prius_front_right_laser_scan
	#left_ranges = left_ranges[:len(left_ranges)-100] # Filter for error
	#right_ranges = right_ranges[100:]  # Filter for error
	left_ranges = self.getRangesForAngle(40,120, left_laser)# Restrict laser data to front angles
	right_ranges = self.getRangesForAngle(120,240, right_laser)
	min_left = min(left_ranges)
	min_right = min(right_ranges)
	error = min_left - min_right
	p = 0.9 * error
	if p &gt; 1: return 1
	elif p &lt; -1: return -1
	else: return p

def calculate_steer_lane(self):
	&quot;&quot;&quot;
	Proportional Steer based on Lane Detected using Front Camera
	&quot;&quot;&quot;
	slopes = self.get_line_slope()
	print(slopes)
	error = 1 - abs(slopes[0])
	p = 0.1 * error
	if p &gt; 1: return 1
	elif p &lt; -1: return -1
	else: return p

def calculate_throttle(self, desired_velocity):
	&quot;&quot;&quot;
	Proportional Throttle Controller
	&quot;&quot;&quot;
	feedback_velocity = np.average(np.array(self.globalNamespace.joint_states.velocity[:4])) # 4 Wheels
	error = desired_velocity - feedback_velocity
	p = 0.5 * error
	if p &gt; 1: return 1
	elif p &lt; -1: return -1
	else: return p

def draw_lines(self, img, lines, color=[255, 0, 0], thickness=3):
	if lines is None:
		return
	img = np.copy(img)
	line_img = np.zeros((img.shape[0], img.shape[1], 3), dtype=np.uint8,)
	for line in lines:
		for x1, y1, x2, y2 in line:
			cv2.line(line_img, (x1, y1), (x2, y2), color, thickness)
	img = cv2.addWeighted(img, 0.8, line_img, 1.0, 0.0)
	return img


def get_line_slope(self):
	'''
	Road Lane Slope Detection
	'''
	front_image = self.globalNamespace.prius_front_camera_image_raw
	import cv2
	from cv_bridge import CvBridge
	self.bridge = CvBridge()
	front_image = self.bridge.imgmsg_to_cv2(front_image, &quot;bgr8&quot;)
	vertices = np.array([[(287, 404), (4, 503), (575, 552), (442,411)]], dtype=np.int32)
	front_image = self.region_of_interest(front_image, vertices)
	front_image_gray = cv2.cvtColor(front_image, cv2.COLOR_BGR2GRAY)
	gray_image = cv2.Canny(front_image_gray, 100, 200)
	lines = cv2.HoughLinesP(gray_image, rho=6, theta=np.pi / 60, threshold=160,
	lines = np.array([]), minLineLength=40, maxLineGap=25)
	display = self.draw_lines(front_image, lines)
	cv2.imshow('lines', display)
	left_line_x = []
	left_line_y = []
	right_line_x = []
	right_line_y = []
	slopes = []
	
	for line in lines:
		for x1, y1, x2, y2 in line:
			slope = (y2 - y1) / (x2 - x1)
			slopes.append(slope)
			if math.fabs(slope) &lt; 0.5:
				continue
			if slope &lt;= 0:
				left_line_x.extend([x1, x2])
				left_line_y.extend([y1, y2])
			else:
				right_line_x.extend([x1, x2])
				right_line_y.extend([y1, y2])
	return slopes

def is_stop_sign(self):
	&quot;&quot;&quot;
	Simple Color Thresholding based Stop Sign Detection
	&quot;&quot;&quot;
	right_laser = self.globalNamespace.prius_front_right_laser_scan
	right_front_ranges = np.array(self.getRangesForAngle(210, 240, right_laser))
	
	if (right_front_ranges &lt; 10).any():
		self.is_stop = True
		return
	self.is_stop = False
	
	</functions>
        <variables>self.is_stop = False
self.turn_complete = False</variables>
      </namespace>
      <state id="3" initial="True">
        <posx>854.0</posx>
        <posy>839.0</posy>
        <name>stay_on_road</name>
        <code>throttle = self.namespace.calculate_throttle(10)
steer = self.namespace.calculate_steer_lane()
command = Control()
command.throttle = throttle
command.brake = 0
command.steer = steer
self.globalNamespace.publishprius(command)</code>
        <timestep>100</timestep>
        <namespace>
          <functions></functions>
          <variables></variables>
        </namespace>
        <transition id="1">
          <type>1</type>
          <condition>self.namespace.is_stop_sign()
return self.namespace.is_stop
</condition>
          <posx>911.5</posx>
          <posy>782.5</posy>
          <name>is_stop_sign</name>
          <originid>3</originid>
          <destinationid>4</destinationid>
          <code></code>
        </transition>
      </state>
      <state id="4" initial="False">
        <posx>970.0</posx>
        <posy>732.0</posy>
        <name>stop_on_sign</name>
        <code>command = Control()
command.throttle = 0
command.brake = 0.6
command.steer = 0
self.globalNamespace.publishprius(command)</code>
        <timestep>100</timestep>
        <namespace>
          <functions></functions>
          <variables></variables>
        </namespace>
        <transition id="2">
          <type>0</type>
          <time>5000</time>
          <posx>1027.0</posx>
          <posy>781.0</posy>
          <name>human_on_road</name>
          <originid>4</originid>
          <destinationid>5</destinationid>
          <code></code>
        </transition>
      </state>
      <state id="5" initial="False">
        <posx>1092.0</posx>
        <posy>836.0</posy>
        <name>turn_right</name>
        <code></code>
        <timestep>100</timestep>
        <namespace>
          <functions></functions>
          <variables></variables>
        </namespace>
        <transition id="7">
          <type>0</type>
          <time>8150</time>
          <posx>1042.5</posx>
          <posy>898.0</posy>
          <name>turning</name>
          <originid>5</originid>
          <destinationid>8</destinationid>
          <code></code>
        </transition>
        <state id="6" initial="True">
          <posx>942.0</posx>
          <posy>818.0</posy>
          <name>Forward</name>
          <code>command = Control()
command.throttle = 0.2
command.brake = 0
command.steer = 0
self.globalNamespace.publishprius(command)</code>
          <timestep>100</timestep>
          <namespace>
            <functions></functions>
            <variables></variables>
          </namespace>
          <transition id="5">
            <type>0</type>
            <time>5700</time>
            <posx>941.5</posx>
            <posy>890.5</posy>
            <name>turn_right</name>
            <originid>6</originid>
            <destinationid>7</destinationid>
            <code></code>
          </transition>
        </state>
        <state id="7" initial="False">
          <posx>943.0</posx>
          <posy>962.0</posy>
          <name>SteerRight</name>
          <code>command = Control()
command.throttle = 0.2
command.brake = 0
command.steer = -0.7
self.globalNamespace.publishprius(command)</code>
          <timestep>100</timestep>
          <namespace>
            <functions></functions>
            <variables></variables>
          </namespace>
        </state>
      </state>
      <state id="8" initial="False">
        <posx>989.0</posx>
        <posy>977.0</posy>
        <name>align_lane</name>
        <code>throttle = self.namespace.calculate_throttle(10)
steer = self.namespace.calculate_steer_lane()
command = Control()
command.throttle = throttle
command.brake = 0
command.steer = steer
self.globalNamespace.publishprius(command)</code>
        <timestep>100</timestep>
        <namespace>
          <functions></functions>
          <variables></variables>
        </namespace>
        <transition id="8">
          <type>0</type>
          <time>4000</time>
          <posx>924.5</posx>
          <posy>950.5</posy>
          <name>stop</name>
          <originid>8</originid>
          <destinationid>9</destinationid>
          <code></code>
        </transition>
      </state>
      <state id="9" initial="False">
        <posx>847.0</posx>
        <posy>926.0</posy>
        <name>Stop</name>
        <code>command = Control()
command.throttle = 0
command.brake = 0.6
command.steer = 0
self.globalNamespace.publishprius(command)</code>
        <timestep>100</timestep>
        <namespace>
          <functions></functions>
          <variables></variables>
        </namespace>
      </state>
    </state>
  </state>
</VisualStates>
